<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Heap</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

							<!-- Header -->
								<header id="header"></header>

							<!-- Content -->
								<section>
									<header class="main">
										<h1>Tree</h1>
									</header>
									<!--
									<span class="image main"><img src="images/pic11.jpg" alt="" /></span>
									-->
									<p></p>

									<hr class="major" />

									<h2>Heap</h2>
									<p>Heap is a tree-based data structure.</p>
									<hr class="major" />
									<h2>Binary Heap</h2>
									<p>A binary heap is a complete binary tree. There are max-heap and min-heap. Binary heaps are a common way of implementing priority queues. Thus, we can say priority queue uses a heap as data structure.</p>
									<h3>Operations on heap</h3>
									<h4>make_heap(iter_first, iter_last)</h4>
									<p>Making a vector into a MAX heap. </p>
									<h4>make_heap(iter_first, iter_last, comp)</h4>
									<p>Making a vector into a MIN heap. The comp parameter is greater<int>().</p>
									<p> * time complexity: O(NlogN), since heapify costs O(logN) and build-heap makes O(N) calls. However, O(NlogN) is the upperbound,though correct. The tighter bound can be O(N). You represent the heap as an array and heap is based on a complete binary tree. The two elements below the i'th element are at positions 2*i+1 and 2*i+2. If the array has n elements then, starting from the end, take each element, and let it "fall" to the right place in the heap. This is O(n) to run.</p>
									<p> * space complexity: Because the make_heap will rearrange the elements in the vector, basically the space for heap is the same as the vector, which is O(N) for heap itself. There might only few variables that are used for doing swaps. </p>
									<p>
<textarea>
	using namespace std; 
	int main() { 
		vector<int> vec = { 4, 9, 7, 8, 11}; 
		  
		// using make_heap() to making a vector into a max heap 
		make_heap(vec.begin(), vec.end()); 
		  
		// front() function 
		cout << "The maximum number in the heap is:"; 
		cout << vec.front(); 
	} 
</textarea>
									</p>
									<p>
<textarea>
	using namespace std; 
	int main() { 
		vector<int> vec = { 4, 9, 7, 8, 11}; 
		  
		// using make_heap() to making a vector into a max heap 
		make_heap(vec.begin(), vec.end(), greater<int>()); 
		  
		// front() function 
		cout << "The minimum number in the heap is:"; 
		cout << vec.front(); 
	} 
</textarea>
									</p>
									<h4>front()</h4> 
									<p>Retrieve the root value in this heap, either a maximum or a minimum value depending on which heap you built.</p>
									<h4>push_heap(iter_first, iter_last)</h4>
									<p>Insert a new value into MAX heap.</p>
									<h4>push_heap(iter_first, iter_last, comp)</h4>
									<p>Insert a new value into MIN heap. The comp parameter is greater<int>().</p>
									<p>
<textarea>
	//MAX HEAP
	vec.push_back(99); 
	push_heap (vec.begin(), vec.end());
	cout << "max heap after push: " << v.front();
	  
	//MIN HEAP
	vec.push_back(99); 
	push_heap (vec.begin(), vec.end(), greater<int>());
	cout << "min heap after push: " << v.front();
</textarea>
									</p>
									<h4>pop_heap(iter_first, iter_last)</h4>
									<p>Delete the maximum or minimum value in the heap, and it depends on which heap you use.</p>
									<p>When we use pop_heap, it will move the maximum or minimum value to the back of the vector, and heapify the elements from 0 to last-2. You need to pop_back the element in the vector to finish the operation.</p>
									<p>
<textarea>
	pop_heap (vec.begin(), vec.end()); 
	vec.pop_back();
</textarea>
									</p>
									<h3> Max Heap</h3>
									<p>Each node is BIGGER than it's left and right children. </p>
									<h3> Min Heap</h3>
									<p>Each node is SMALLER than it's left and right children. </p> 
									<span class="image main"><img src="images/heap.png" alt="" /><p>(The above image is from https://www.geeksforgeeks.org/heap-data-structure/.)</p></span>
									<hr class="major" />
									<h2>Priority Queue</h2>
									<p>Even though priority queue acts like a queue, it implements binary heap data strcuture.</p>
									<h3>Operations on priority queue</h3>
									<h4>empty()</h4>
									<p>Return bool value. True if the priority queue is empty, otherwise return false.</p>
									<h4>size()</h4>
									<p>Return number of elements in the priority queue.</p>
									<h4>top()</h4>
									<p>Triger front() once.</p>
									<h4>pop()</h4>
									<p>Triger push_back() once and then push_heap() once. Same way and order as heap does.</p>
									<h4>push()</h4>
									<p>Triger pop_heap() once and then pop_back() once. Same way and order as heap does.</p>
									<p>
<textarea>
	// priority_queue::empty
	#include <iostream>       // cout
	#include <queue>          // priority_queue

	int main () {
	priority_queue<int> mypq;
	int sum (0);

	for (int i=1;i<=10;i++) 
		mypq.push(i);

	while (!mypq.empty()) {
		sum += mypq.top();
		mypq.pop();
	}

	cout << "total: " << sum << '\n';

	return 0;
	}
</textarea>
									</p>
									<h4>priority_queue(int)</h4>
									<p>Decreasing order</p>
									<h4>priority_queue<int, vector<int>, greater<int>></h4>
									<p>Increasing order</p>
									<hr class="major" />
									<p><a href = "https://leetcode.com/problems/k-closest-points-to-origin/">[Medium] No.973 K Closest Points to Origin</a></p>
									<p>Approach: priority queue</p>
									<p>Time Complexity: O(NlogN), where N is the number of nodes in the vector, and heap sorting costs O(NlogN).</p>
									<p>Space Complexity: O(N), where N is the number of nodes need to store in the priority queue.</p>
									<p class = "code solution">
<textarea>
	class Solution {
		public:
			typedef pair<int,pair<int,int>> PAIR;
			
			vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {
				priority_queue<PAIR, vector<PAIR>,greater<PAIR>> pq;
				vector<vector<int>> ans;
				for(auto point : points) {
					pq.push({point[0]*point[0] + point[1]*point[1], {point[0],point[1]}});
				}
		
				while(!pq.empty() && K > 0) {
					pair<int,pair<int,int>> cur = pq.top();
					pq.pop();
					ans.push_back({cur.second.first, cur.second.second});
					K--;
				}
				return ans;
			}
		};
</textarea>
									</p>
									<hr class="major" />
									<h2>Binominal Heap</h2>
									<p>Faster than binary heap.</p>
									<h3>Definition</h3>
									<p></p>
									<hr class="major" />
									<h2>Fibonacci Heap</h2>
									<p>Faster than binary heap and binominal heap.</p>
						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
						<div class="inner">

							<!-- Search -->
								<section id="search" class="alt">
									<form method="post" action="#">
										<input type="text" name="query" id="query" placeholder="Search" />
									</form>
								</section>

							<!-- Menu -->
								<nav id="menu">
									<ul>
										<li><a href="index.html">Homepage</a></li>
										<li><a href="linkedlist.html">Linked List</a></li>
										<li>
											<span class="opener">Contianer</span>
											<ul>
												<li><a href="vector.html">Vector</a></li>
												<li><a href="string.html">String</a></li>
												<li><a href="matrix.html">Matrix</a></li>
												<li><a href="array.html">Array</a></li>
												<li><a href="stack.html">Stack</a></li>
												<li><a href="queue.html">Queue</a></li>
												<li><a href="map.html">Map</a></li>
												<li><a href="set.html">Set</a></li>
											</ul>
										</li>
										<li>
											<span class="opener">Tree</span>
											<ul>
												<li><a href="tree basic concept.html">Basic Concept</a></li>
												<li><a href="bt.html">Binary Tree</a></li>
												<li><a href="bst.html">Binary First Search</a></li>
												<li><a href="trie.html">Trie</a></li>
												<li><a href="heap.html">Heap</a></li>
											</ul>
										</li>
										<li><a href="iteration.html">Iteration</a></li>
										<li><a href="recursion.html">Recursion</a></li>
										<li><a href="dfs.html">DFS</a></li>
										<li><a href="bfs.html">BFS</a></li>
										<li><a href="graph.html">Graph</a></li>
										<li><a href="dp.html">Dynamic Programming</a></li>
										<li>
											<span class="opener">Sorting</span>
											<ul>
												<li><a href="insertionSort.html">Insertion Sort</a></li>
												<li><a href="bubbleSort.html">Bubble Sort</a></li>
												<li><a href="quickSort.html">Quick Sort</a></li>
												<li><a href="mergeSort.html">Merge Sort</a></li>
											</ul>
										</li>
										<li><a href="slidewindow.html">Slide Window</a></li>
										<li><a href="greedy.html">Greedy Algorithm</a></li>
										<li><a href="divide.html">Divide and Conquer</a></li>
									</ul>
								</nav>
							<!-- Footer -->
								<footer id="footer">
									<p class="copyright">&copy; 2020 Kairui Hsu. All rights reserved. Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
								</footer>

						</div>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>